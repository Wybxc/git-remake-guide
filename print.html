<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Git 重学指南</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/sidetoc.css">
        <link rel="stylesheet" href="assets/custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="Git-重学指南.html">Git 重学指南</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="安装/安装.html"><strong aria-hidden="true">1.</strong> 安装</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="安装/下载.html"><strong aria-hidden="true">1.1.</strong> 下载</a></li><li class="chapter-item expanded "><a href="安装/配置.html"><strong aria-hidden="true">1.2.</strong> 配置</a></li></ol></li><li class="chapter-item expanded "><a href="储存库/储存库.html"><strong aria-hidden="true">2.</strong> 储存库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="储存库/创建储存库.html"><strong aria-hidden="true">2.1.</strong> 创建储存库</a></li><li class="chapter-item expanded "><a href="储存库/管理暂存区.html"><strong aria-hidden="true">2.2.</strong> 管理暂存区</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 远程和分支</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 工作流程</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 杂项</div></li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 附录</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> 语义化版本</div></li><li class="chapter-item expanded "><a href="附录/约定式提交.html"><strong aria-hidden="true">6.2.</strong> 约定式提交</a></li><li class="chapter-item expanded "><a href="附录/gitmoji-速查表.html"><strong aria-hidden="true">6.3.</strong> gitmoji 速查表</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Git 重学指南</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Wybxc/git-remake-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 id="git-重学指南"><a class="header" href="#git-重学指南">Git 重学指南</a></h1>
<blockquote>
<p>不要因为学不会 Git 而选择 remake。在那之前，先来 remake 一下你的 Git 知识。</p>
</blockquote>
<p>这是一篇 Git 重学指南，顾名思义，帮助你重新学习 Git。它适用于<strong>已经学习过 Git，但是还想再学一遍</strong>的人。</p>
<h2 id="为什么要再学一遍"><a class="header" href="#为什么要再学一遍">为什么要再学一遍？</a></h2>
<p>我相信很多人和我一样，第一次知道 Git 是因为 GitHub。为了把自己的代码上传到 GitHub，上网随便找了一篇 Git 教程，匆匆浏览一遍，大概记住了几个命令，然后就开始使用 Git。最开始还没有什么问题，但是当你的项目做大了，或者有人向你发来了第一个 Pull Request，或者你想给项目发布第一个 Release，问题就接踵而至。</p>
<ul>
<li>那些教程里讲的分支、合并、回滚，我应该在什么时候用？</li>
<li>Pull Request 里的合并冲突为什么要在本地解决？</li>
<li>Release 里的 tag 到底是打在哪里的？</li>
<li>我的项目依赖是否应该用 submodule 引入？</li>
<li>Monorepo 又是怎么实现的？</li>
</ul>
<p>假如你对这些问题还是一头雾水，这说明，<strong>你的 Git 知识需要 remake 了</strong>。继续阅读本书，一定会对你有所帮助。</p>
<p>当然，如果你能清晰地回答出每个问题的正确答案，那么你的知识水平已经超过我了 :D。你可以继续往后翻一翻，看看文章中是不是有错误，指出来，或者帮我改正它。</p>
<h2 id="如果我没学过-git-呢"><a class="header" href="#如果我没学过-git-呢">如果我没学过 Git 呢？</a></h2>
<p>如果你从来没有学过 Git，我的建议是先去阅读其他的教程，比如<a href="https://github.com/geeeeeeeeek/git-recipes">Git 菜单</a>和<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖大的教程</a>，他们对初学者来说，绝对比这本书友好。</p>
<h2 id="这里讲的一定是正确的吗"><a class="header" href="#这里讲的一定是正确的吗">这里讲的一定是正确的吗？</a></h2>
<p>老实说，我不确定。因为我本人也是正处于 remake 我的 Git 知识的阶段，这本书相当于我重学的笔记，所以难免会有一些错误。</p>
<p>另一方面，这本书会涉及到很多“最佳实践”。众所周知，“最佳实践”永远不是最完美的解决方案。而且，“最佳实践”难免带有我个人的喜好。我会尽可能做到客观，还希望诸位自行甄别扬弃。</p>
<h2 id="许可"><a class="header" href="#许可">许可</a></h2>
<p><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享许可协议" /></a></p>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装"><a class="header" href="#安装">安装</a></h1>
<p>既然是重新学习，那么安装想必是已经会了。</p>
<p>不过还是简单说一下，就当是参考手册吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="下载"><a class="header" href="#下载">下载</a></h1>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>大部分情况下，可以用发行版自带的软件包管理器安装。</p>
<pre><code class="language-bash"># Debian/Ubuntu
sudo apt-get install git

# Debian/Ubuntu (old version)
sudo apt-get install git-core

# RedHat/CentOS
sudo yum install git
</code></pre>
<h2 id="mac-os"><a class="header" href="#mac-os">Mac OS</a></h2>
<p>使用 Homebrew。</p>
<pre><code class="language-bash">brew install git
</code></pre>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<blockquote>
<p>Windows 永远是安装开发工具最麻烦的那一个。</p>
</blockquote>
<p>在 Windows 上安装 Git 的最佳选择是使用 Git for Windows，它自带了一个精简的 MSYS2 环境。</p>
<h3 id="使用-winget"><a class="header" href="#使用-winget">使用 winget</a></h3>
<p>新版本 Windows 11 和 Windows 10 已经支持 winget，它可以打造像 Linux 发行版那样一键安装的良好体验。</p>
<p>如果你的 Windows 10 没有更新到最新版，可以先<a href="https://www.microsoft.com/p/app-installer/9nblggh4nns1#activetab=pivot:overviewtab">从 Micosoft Store 安装「应用安装程序」</a>（其实就是 winget）。</p>
<pre><code class="language-shell">winget install --id Git.Git -e --source winget
</code></pre>
<p>唯一的缺点是它会自动连接 GitHub，在网络环境不那么通畅的时候，懂的都懂。</p>
<h3 id="下载安装程序"><a class="header" href="#下载安装程序">下载安装程序</a></h3>
<p>如果不使用 winget，可以下载安装程序，然后手动安装。安装程序可以从<a href="https://git-scm.com/download/win">官网</a>，或者国内访问速度更快的<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">淘宝镜像</a>获取。</p>
<h3 id="git-for-windows-的安装配置"><a class="header" href="#git-for-windows-的安装配置">Git for Windows 的安装配置</a></h3>
<p>Git for Windows 在安装时提供的可配置选项极其复杂。虽然默认配置已经很不错了，不过想自己配置一下也是可以的。</p>
<p>下面对几个常用但有些困惑的选项进行解释。</p>
<h4 id="windows-explorer-integration"><a class="header" href="#windows-explorer-integration">Windows Explorer integration</a></h4>
<p>向右键菜单中添加「Git Bash Here」「Git GUI Here」选项。</p>
<p>大多数情况下，Windows Terminal 和代码编辑器的 git 集成可以完全代替这两个功能，所以不建议打开。</p>
<h4 id="adjusting-your-path-environment"><a class="header" href="#adjusting-your-path-environment">Adjusting your PATH environment</a></h4>
<p>决定将什么添加进 PATH 环境变量中。</p>
<p>默认的选项，也是推荐的选项，是只添加 <code>git</code> 命令。</p>
<p>第三个选项是将整个 MSYS2 环境添加进 PATH 环境变量中，但不要以为就可以借此使用 MSYS2 了，因为 Git for Windows 的 MSYS2 精简掉了很多东西，如果想用 MSYS2，还是单独装一个吧。</p>
<h4 id="configuring-the-line-ending-conversions"><a class="header" href="#configuring-the-line-ending-conversions">Configuring the line ending conversions</a></h4>
<p>设置换行符的转换。</p>
<p>这是一个 Windows 独有的选项，因为只有 Windows 系统的换行符是 CRLF。</p>
<p>默认的选项是推荐的选项，表示在本地的代码中统一使用 CRLF，但在 git 储存中统一使用 LF。这表示你的代码在 <code>git add</code> 的时候会经过从 CRLF 到 LF 的转换，而在 <code>git clone</code> 或者 <code>git checkout</code> 的时候会经过从 LF 到 CRLF 的转换。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置"><a class="header" href="#配置">配置</a></h1>
<h2 id="名字和邮箱"><a class="header" href="#名字和邮箱">名字和邮箱</a></h2>
<p>在命令行输入：</p>
<pre><code class="language-bash">git config --global user.name &quot;Your Name&quot;
git config --global user.email &quot;email@example.com&quot;
</code></pre>
<p>因为 Git 是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和邮箱。大多数情况下，Git 就是靠这些来确定身份的。</p>
<p>注意 <code>git config</code> 命令的 <code>--global</code> 参数，这表示将配置设置为全局的。全局设置对本机的每个仓库都生效。</p>
<h2 id="ssh-密钥"><a class="header" href="#ssh-密钥">SSH 密钥</a></h2>
<p>SSH 密钥用于连接 GitHub 或者类似的托管服务。</p>
<p>首先查看你的 SSH 密钥是否已经生成。</p>
<pre><code class="language-bash">ls ~/.ssh
</code></pre>
<p>如果你没有生成过 SSH 密钥，那么这个目录应该是不存在的。你可以使用 <code>ssh-keygen</code> 命令来生成一个新的密钥。</p>
<pre><code class="language-bash">ssh-keygen -t rsa
</code></pre>
<p>如果在 Windows 系统上找不到 <code>ssh-keygen</code> 命令，那么可以在 Git Bash 中运行。</p>
<p>生成完成后，查看生成的公钥：</p>
<pre><code class="language-bash">cat ~/.ssh/id_rsa.pub
</code></pre>
<p>在 GitHub 上添加这个公钥，然后检测一下是否成功：</p>
<pre><code>$ ssh git@github.com
PTY allocation request failed on channel 0
Hi Wybxc! You've successfully authenticated, but GitHub does not provide shell access.
Connection to github.com closed.
</code></pre>
<p>看到这样的欢迎信息，说明 SSH 密钥添加成功。</p>
<h2 id="gpg-密钥"><a class="header" href="#gpg-密钥">GPG 密钥</a></h2>
<p>上面提到 Git 在确定身份的时候用的是名字和邮箱，但是，这也意味着只要知道了别人的名字和邮箱，就可以冒充他的身份。理论上，这种冒充是无法甄别的，甚至 GitHub 也无法避免。</p>
<p>所以，在名字和邮箱以外，Git 还有另一重保护措施：GPG 密钥。你可以使用自己的 GPG 私钥对提交进行签名，这样别人就能通过公钥鉴定身份。如果你的所有提交都经过签名，那么别人就知道没有签名的那些提交就是冒牌货。</p>
<p>生成 GPG 密钥：</p>
<pre><code class="language-shell">gpg --full-generate-key
</code></pre>
<p>如果在 Windows 系统上提示找不到 gpg 命令，可以在 Git Bash 中运行。</p>
<p>基本按照默认配置即可。生成时需要填写名字和邮箱，需要和 Git 的配置一致，而且邮箱需要和 GitHub 账号认证的邮箱一致。</p>
<p>如果生成的是 RSA 密钥，需要设置密钥长度。GitHub 要求 RSA 密钥是 4096 位。</p>
<p>生成过程中会给密钥设置密码，这个密码是解锁私钥的关键。</p>
<p>生成完成后，查看生成的密钥：</p>
<pre><code>$ gpg --list-secret-keys --keyid-format LONG
~/.gnupg/pubring.kbx
-----------------------------------------------
sec   ed25519/85E18D73E1B2E193 2022-06-15 [SC]
      6BBEA37A752DBC75008ABB6B85E18D73E1B2E193
uid                 [ultimate] 忘忧北萱草 &lt;wybxc@qq.com&gt;
ssb   cv25519/FB6CDE598D2CD679 2022-06-15 [E]
</code></pre>
<p>这里的 <code>85E18D73E1B2E193</code> 就是密钥 ID。</p>
<p>将 GPG 与 git 相关联：</p>
<pre><code class="language-shell">git config --global user.signingkey 85E18D73E1B2E193
git config --global commit.gpgsign true
</code></pre>
<p>如果配置 GPG 之后，提交时 Git 找不到 GPG，那么可以手动设置一下 GPG 的路径：</p>
<pre><code class="language-shell">$ which gpg
/usr/bin/gpg
$ git config --global gpg.program /usr/bin/gpg
</code></pre>
<p>接下来导出 GPG 公钥，然后添加到 GitHub 中：</p>
<pre><code>$ gpg --armor --export 85E18D73E1B2E193
-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEYqn6LBYJKwYBBAHaRw8BAQdAdUKrYViGQwyP6OvG0zi4BtkztQSHmVSzJweG
RH5YbkC0HuW/mOW/p+WMl+iQseiNiSA8d3lieGNAcXEuY29tPoiTBBMWCgA7FiEE
a76jenUtvHUAirtrheGNc+Gy4ZMFAmKp+iwCGwMFCwkIBwICIgIGFQoJCAsCBBYC
AwECHgcCF4AACgkQheGNc+Gy4ZMLvgD+LPHZ/61I3V2QtcQxjhE7Mmx/zzf7nMu9
yoKsBS0DoHsBAOmGcnz8Ldxt8g5annPoS4JXhyC0vUgvBl5ks+LQ6WILuDgEYqn6
LBIKKwYBBAGXVQEFAQEHQKwoXBZT20+8mEfaqAuSEyMi4eeiE1Adjkj0TCZuV2UE
AwEIB4h4BBgWCgAgFiEEa76jenUtvHUAirtrheGNc+Gy4ZMFAmKp+iwCGwwACgkQ
heGNc+Gy4ZOtkwEAuyAAI2Va4xNuXwWf+WZg7Bt5KcXfcezYGG3EDFstaJMA/i6O
B1wiq7kByLBFmRVBGewKpDA2Z2UGnAQuSvCY5nwF
=FzfD
-----END PGP PUBLIC KEY BLOCK-----
</code></pre>
<p>之后，提交的 commit 在 GitHub 上就会显示 <code>verified</code>，表明这条 commit 是通过了 GPG 签名认证的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="储存库"><a class="header" href="#储存库">储存库</a></h1>
<p>储存库，或者叫版本库、代码仓库，英文名 repository，是 Git 用来存储和管理程序的源代码的结构。我们在本地开发的大部分时间，都是在和储存库斗智斗勇。</p>
<p>实际上，<strong>储存库是 Git 中唯一核心的概念</strong>。所有的 Git 操作，都是围绕着管理和同步储存库来进行的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建储存库"><a class="header" href="#创建储存库">创建储存库</a></h1>
<blockquote>
<p>本节部分内容参考自 <a href="https://github.com/geeeeeeeeek/git-recipes/blob/master/sources/2.2-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93.md">git-recipes</a>，在原文基础上有一定修改。</p>
</blockquote>
<h2 id="git-init"><a class="header" href="#git-init">git init</a></h2>
<p><code>git init</code> 命令创建一个新的 Git 储存库。它可以在一个已经有文件的储存库中使用，用来将已存在但还没有版本控制的项目转换成一个 Git 储存库，或者在一个空文件夹里使用，创建一个空的新储存库。</p>
<p>运行 <code>git init</code> 命令会在你项目的根目录下创建一个新的 <code>.git</code> 目录，其中包含了你项目必需的所有元数据。除了 <code>.git</code> 目录之外，已经存在的文件不会被改变。</p>
<h3 id="详细用法"><a class="header" href="#详细用法">详细用法</a></h3>
<details>
<summary>点击展开</summary>
<pre><code>git init
</code></pre>
<p>将当前的目录转换成一个 Git 储存库。它在当前的目录下增加了一个 <code>.git</code> 目录，于是就可以开始记录项目版本了。</p>
<pre><code>git init &lt;directory&gt;
</code></pre>
<p>在指定目录创建一个空的 Git 储存库。运行这个命令会在当前目录下创建一个名为 <code>directory</code>，只包含 <code>.git</code> 子目录的空目录。</p>
<pre><code>git init --bare &lt;directory&gt;.git
</code></pre>
<p>初始化一个裸的 Git 储存库（无工作树）。这个目录会创建一个名为 <code>&lt;directory&gt;.git</code> 的目录，其中包含了一个储存库的元信息。裸的储存库一般用作服务器上的共享储存库。关于裸的储存库，后文会详细解释。</p>
</details>
<h2 id="git-clone"><a class="header" href="#git-clone">git clone</a></h2>
<p><code>git clone</code> 命令拷贝整个 Git 仓库。这个命令获取到的副本是一个完备的Git仓库——它包含自己的历史，管理自己的文件，并且环境和原仓库完全隔离。</p>
<p>为了方便起见，Git 在 clone 时会自动创建一个名为 <code>origin</code> 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单。</p>
<p>如果项目在远程仓库已经设置完毕，<code>git clone</code> 是用户获取开发副本最常见的方式。和 <code>git init</code> 相似，clone 通常也是一次性的操作——只要开发者获得了一份工作副本，所有版本控制操作和协作管理都是在本地仓库中完成的。</p>
<h3 id="详细用法-1"><a class="header" href="#详细用法-1">详细用法</a></h3>
<details>
<summary>点击展开</summary>
<pre><code>git clone &lt;repo&gt;
</code></pre>
<p>将位于 <code>repo</code> 的仓库克隆到本地机器。原仓库可以在本地文件系统中，或是通过 HTTP 或 SSH 连接的远程机器。</p>
<pre><code>git clone &lt;repo&gt; &lt;directory&gt;
</code></pre>
<p>将位于 <code>repo</code> 的仓库克隆到本地机器上的 <code>directory</code> 目录。</p>
</details>
<h2 id="谁是本体"><a class="header" href="#谁是本体">谁是本体？</a></h2>
<p>当我们用 <code>git init</code> 创建储存库的时候，Git 只是在当前目录下创建了一个 <code>.git</code> 目录。而如果我们手动把这个目录删掉，它就又从储存库变回原本平平无奇的文件夹了。整个过程中，Git 没有对原本的文件做出任何破坏性的改变。</p>
<p>看来所有的秘密都藏在这个 <code>.git</code> 目录中了。Git 到底对这个目录用了什么魔法？</p>
<p>当我们在开发时，99.999% 的时间都是在和我们自己的代码打交道，<code>.git</code> 文件夹对我们而言是一个黑箱。所以，有的时候，我们可能会产生一种错觉，认为我们能看到的代码是本体，而 <code>.git</code> 只是 Git 提供的附属品而已。</p>
<p>但事实并非如此。从我们敲下 <code>git init</code> 的那一刻开始，世界在 Git 的眼中就发生了改变。<strong>在 Git 看来，那个不起眼的 <code>.git</code> 才是储存库的本体，其他的一切都是它的附属品。</strong></p>
<p>没错，就和一些漫画中的人物一样，「眼镜才是本体」。</p>
<h2 id="储存库和工作树"><a class="header" href="#储存库和工作树">储存库和工作树</a></h2>
<h3 id="什么是工作树"><a class="header" href="#什么是工作树">什么是工作树？</a></h3>
<p>在 Git 眼中，真正的储存库只是那一个 <code>.git</code> 文件夹。而在外面天天被我们盯着看的东西，在 Git 的世界里叫做「<strong>工作树 (worktree)</strong>」。</p>
<p>一个 Git 储存库可以有一个或多个工作树，甚至可以没有工作树。我们用 <code>git init</code> 和 <code>git clone</code> 建立的，都是一个储存库和一个工作树的组合，这样建立的工作树称为「主工作树」。</p>
<p>用 <code>git worktree list</code> 命令，可以查看当前 Git 储存库中的所有工作树。</p>
<pre><code>$ git worktree list
E:/git-remake-guide  5c64c4d [创建储存库]
</code></pre>
<h3 id="git-的文件系统"><a class="header" href="#git-的文件系统">Git 的文件系统</a></h3>
<p>在 Git 中，文件以两种形式存放：在储存库中，按照 Git 的格式将每一个版本储存为一个个 <code>object</code>，并按照更改历史、提交信息等等建立索引；在工作树中，按照一般的操作系统可识别的文件系统的方式存放。由于在储存库中，文件存在多个版本，而且并不是按照目录结构存放的，所以，对储存库中的文件不能直接编辑，而是要通过 Git 命令提取到工作树之后再编辑。</p>
<p>从储存库中取出文件，将其置入工作树中的操作，称为「<strong>签出（checkout）</strong>」。没错，就是熟悉的 <code>git checkout</code> 命令。</p>
<p>而与之对应的，将工作树中的文件写入储存库的操作，称为「签入」。签入操作没有一个单独的命令对应，而是通过 <code>git add</code> <code>git commit</code> 等一系列命令来完成。</p>
<p>一般情况下，开发的流程是这样的：先从储存库中签出文件，然后在工作树中修改文件，最后进行签入，把工作树中的文件写入储存库。</p>
<p>所以，Git 的储存库不仅包含着工作树中全部的内容，也包含着工作树全部的历史。就算把工作树删掉，依然可以从储存库中签出一个工作树的版本出来。</p>
<h3 id="裸仓库"><a class="header" href="#裸仓库">裸仓库</a></h3>
<p>工作树的存在，是为了方便对储存库内容进行编辑。有的时候，我们只需要 Git 储存库，而不需要工作树。比如，像 GitHub 这样的托管服务上，只需要知道用户的储存库，而不用管理一个工作树。</p>
<p>像这样没有工作树，只有储存库的情况，称为「裸仓库」。</p>
<p>用 <code>git init --bare &lt;directory&gt;.git</code> 命令，可以创建一个裸仓库。这个命令会在当前文件夹下建立一个名为 <code>directory.git</code> 的文件夹，其中的文件结构和一般的 <code>.git</code> 如出一辙。</p>
<p>Git 约定裸仓库的名称以 <code>.git</code> 结尾。这就是为什么我们看到的 GitHub 上的储存库链接的结尾都是 <code>XXX.git</code>；实际上，这就是一个裸仓库的文件夹名。</p>
<p>既然我们可以克隆一个 GitHub 上的裸仓库，我们当然也能克隆一般的储存库。你可以找一个本地的 Git 储存库，然后克隆它试试：</p>
<pre><code>$ git clone E:\git-remake-guide\.git
Cloning into 'git-remake-guide'...
done.
$ lsd --tree --classic .\git-remake-guide\
git-remake-guide
├── assets
│   ├── custom.css
│   ├── sidetoc.css
│   └── sidetoc.js
├── book.toml
├── README.md
├── src
│   ├── Git-重学指南.md
│   ├── SUMMARY.md
└── theme
    ├── favicon.png
    ├── favicon.svg
    └── index.hbs
</code></pre>
<p>完美。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="管理暂存区"><a class="header" href="#管理暂存区">管理暂存区</a></h1>
<blockquote>
<p>本节部分内容参考自 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93">Pro Git</a> 和 <a href="https://github.com/geeeeeeeeek/git-recipes/blob/master/sources/2.4-%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81.md">git-recipes</a>，在原文基础上有一定修改。</p>
</blockquote>
<p>在开始之前，先上一张图：</p>
<p><img src="%E5%82%A8%E5%AD%98%E5%BA%93/./Git-%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81.svg" alt="Git 文件状态" /></p>
<p>看完这张图，我相信你已经懂了。你可以跳过下面的内容继续看下一节了。</p>
<h2 id="文件的状态变化周期"><a class="header" href="#文件的状态变化周期">文件的状态变化周期</a></h2>
<p>工作目录下的每一个文件都不外乎两种状态：<strong>已跟踪 (tracked)</strong> 或 <strong>未跟踪 (untracked)</strong>。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能是<strong>未修改 (unmodified)</strong>，<strong>已修改 (modified)</strong> 或<strong>已暂存 (staged)</strong>。简而言之，已跟踪的文件就是 Git 已经知道的文件。</p>
<p>工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚签出了它们，而你尚未编辑过任何东西。</p>
<p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。</p>
<p>总结一下，<strong>在 Git 中，正常的文件状态变化周期是：在已跟踪的三种状态（未修改、已修改、已暂存）中不断循环，或者进入和退出未跟踪状态。</strong></p>
<h2 id="查看文件状态"><a class="header" href="#查看文件状态">查看文件状态</a></h2>
<h3 id="git-status"><a class="header" href="#git-status">git status</a></h3>
<p><code>git status</code> 命令显示工作目录和暂存区的状态。你可以看到哪些更改被暂存了，哪些还没有，以及哪些还未被 Git 追踪。</p>
<pre><code>$ git status
On branch 管理暂存区
Changes to be committed:
  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
        new file:   src/储存库/Git-文件状态.svg

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)
        modified:   src/SUMMARY.md
        deleted:    test.txt

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
        src/储存库/管理暂存区.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>这就是一个典型的 <code>git status</code> 的输出，它显示了哪些文件是已暂存的，哪些文件是已修改的，哪些文件是未跟踪的。</p>
<h3 id="状态简览"><a class="header" href="#状态简览">状态简览</a></h3>
<p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出。</p>
<pre><code>$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
</code></pre>
<p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： <code>README</code> 文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code> 文件已修改且已暂存。<code>Rakefile</code> 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p>
<h2 id="暂存新文件"><a class="header" href="#暂存新文件">暂存新文件</a></h2>
<h3 id="git-add"><a class="header" href="#git-add">git add</a></h3>
<p><code>git add</code> 命令将文件提交到暂存区。使用这个命令提交的文件，会直接变成已暂存的状态。最开始的那张图上，所有指向「已暂存」的箭头，都是通过 <code>git add</code> 命令实现的。</p>
<p><code>git add</code> 的另一个作用是将在工作目录中删除的文件在暂存区标记为已删除。当 Git 发现 <code>git add</code> 提交的文件在暂存区或储存库中存在，而在工作目录中不存在时，会将一条删除记录添加到暂存区，表示该文件已被删除。</p>
<p>当 <code>git add</code> 作用于目录时，Git 会对目录中所有的文件递归地应用 <code>git add</code> 的功能。所以 <code>git add .</code> 命令可以一次性将工作目录中所有的新增、修改、删除的文件都提交到暂存区。</p>
<h4 id="详细用法-2"><a class="header" href="#详细用法-2">详细用法</a></h4>
<details>
<summary>点击展开</summary>
<pre><code>git add &lt;file&gt;
</code></pre>
<p>将 <code>&lt;file&gt;</code> 中的更改加入下次提交的缓存。</p>
<pre><code>git add &lt;directory&gt;
</code></pre>
<p>将 <code>&lt;directory&gt;</code> 下的更改加入下次提交的缓存。</p>
<pre><code>git add -i
</code></pre>
<p>开始交互式的缓存，你可以选择文件的一部分加入到下次提交缓存。它会向你展示一堆更改，等待你输入一个命令。y 将这块更改加入缓存，n 忽略这块更改，s 将它分割成更小的块，e 手动编辑这块更改，以及 q 退出。</p>
</details>
<h3 id="git-rm"><a class="header" href="#git-rm">git rm</a></h3>
<p><code>git rm</code> 命令用于删除工作目录或暂存区中的文件。它可以将删除记录写入暂存区，或者将文件从暂存区删除。</p>
<p><code>git rm</code> 是安全的。只有当 Git 确信删除操作是可恢复的时候，才会直接执行删除操作。比如说，如果试图 <code>git rm</code> 一个已修改的文件，Git 就会给出提醒，当然你可以用 <code>-f</code> 无视这一安全性，强行删除一个已修改的文件。</p>
<p>如果你想保留工作目录中的文件，但是删除对应暂存区中的文件，请使用 <code>--cached</code> 选项。为什么会有这种奇怪的需求呢？假设这样一种场景，你忘记了添加 <code>.gitignore</code> 文件，不小心把很多本应忽略的文件加到了暂存区，这时候就需要这里介绍的做法了。</p>
<h3 id="git-mv"><a class="header" href="#git-mv">git mv</a></h3>
<p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么。</p>
<p>你依然可以使用 <code>git mv file_from file_to</code> 对文件改名。它会恰如预期般正常工作。实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p>
<pre><code>$ git mv README.md README
$ git status
On branch master
Changes to be committed:
    (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
        renamed: README.md -&gt; README        
</code></pre>
<p>事实上，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p>
<pre><code>mv README.md README
git rm README.md
git add README
</code></pre>
<p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。两者唯一的区别是，<code>git mv</code> 是一条命令而另一种方式需要三条命令，直接用 <code>git mv</code> 轻便得多。不过有时候用其他工具批处理改名的话，要记得在提交前 <code>git rm</code> 删除旧文件名，再 <code>git add</code> 添加新文件名。</p>
<h2 id="忽略文件"><a class="header" href="#忽略文件">忽略文件</a></h2>
<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。来看一个实际的 <code>.gitignore</code> 例子：</p>
<pre><code>$ cat .gitignore
*.[oa]
*~
</code></pre>
<p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 <code>log</code>，<code>tmp</code> 或者 <code>pid</code> 目录，以及自动生成的文档等等。要养成一开始就为你的新仓库设置好 <code>.gitignore</code> 文件的习惯，以免将来误提交这类无用的文件。</p>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 # 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li>
<li>匹配模式可以以（/）开头防止递归。</li>
<li>匹配模式可以以（/）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。使用两个星号（<code>**</code>）表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p>
<p>我们再看一个 <code>.gitignore</code> 文件的例子：</p>
<pre><code># 忽略所有的 .a 文件
*.a

# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
!lib.a

# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
/TODO

# 忽略任何目录下名为 build 的文件夹
build/

# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
doc/*.txt

# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf
</code></pre>
<h2 id="跳出状态周期循环"><a class="header" href="#跳出状态周期循环">跳出状态周期循环</a></h2>
<p>让我们先复习一下上面说的 Git 文件状态周期循环。</p>
<pre><code>              +----------------------+
              |                      |
          +---v----+           +-----+-----+
    +-----&gt; Staged +-----+     | Untracked |
    |     +--------+     |     +-----^-----+
    |                    |           |
    |                    |           |
+---+------+      +------v-----+     |
| Modified &lt;------+ Unmodified +-----+
+----------+      +------------+
</code></pre>
<h3 id="不正常的状态周期"><a class="header" href="#不正常的状态周期">“不正常”的状态周期</a></h3>
<p>在上面我也提到了，这张图是“正常的”状态周期。那么，有没有“不正常”的状态周期呢？</p>
<p>实际上我们已经见识过了，就是 <code>git rm</code> 命令的两个选项：<code>--cached</code> 和 <code>-f</code>。前者可以把已暂存的文件变成其他状态，后者更是可以强行把任何文件变成未跟踪状态并且从硬盘上删除。这些操作对应的箭头，都是在正常的状态周期中没有出现的。</p>
<p>下面这个表格展示了在文件在不同状态之间的转换：</p>
<table><thead><tr><th style="text-align: center"></th><th style="text-align: center">从「未跟踪」</th><th style="text-align: center">从「未修改」</th><th style="text-align: center">从「已修改」</th><th style="text-align: center">从「已暂存」</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>到「未跟踪」</strong></td><td style="text-align: center">-</td><td style="text-align: center"><code>git rm</code></td><td style="text-align: center"><em><code>git rm -f</code></em></td><td style="text-align: center"><em><code>git rm --cached</code></em></td></tr>
<tr><td style="text-align: center"><strong>到「未修改」</strong></td><td style="text-align: center">-</td><td style="text-align: center">-</td><td style="text-align: center"><em><code>git checkout</code></em></td><td style="text-align: center"><code>git commit</code></td></tr>
<tr><td style="text-align: center"><strong>到「已修改」</strong></td><td style="text-align: center">-</td><td style="text-align: center">edit file</td><td style="text-align: center">-</td><td style="text-align: center"><em><code>git rm --cached</code></em></td></tr>
<tr><td style="text-align: center"><strong>到「已暂存」</strong></td><td style="text-align: center"><code>git add</code></td><td style="text-align: center">-</td><td style="text-align: center"><code>git add</code></td><td style="text-align: center">-</td></tr>
</tbody></table>
<p>表格中 <code>-</code> 表示无需转换或不能转换。斜体标出的是所谓的“不正常”状态周期操作。</p>
<h3 id="不正常-vs-不允许"><a class="header" href="#不正常-vs-不允许">不正常 vs 不允许</a></h3>
<p>其实，所谓的“不正常”是我自造的一个说法。<strong>这些“不正常”的操作，并非不允许这么做，实际上它们完全是被允许的</strong>，不然 Git 就不会提供干这些事情的命令了。</p>
<p>我把它们叫做“不正常”，是因为<strong>在某些情况下，它们是不安全的，也就是说，有可能造成不可逆的后果</strong>。在敲下这些命令之前，请再三确认，你确实知道你在做什么，并且对于这些命令的结果有清晰的预期。如果因为这些命令搞乱了你的仓库，你需要为自己负责。</p>
<h2 id="关于未跟踪"><a class="header" href="#关于未跟踪">关于「未跟踪」</a></h2>
<h3 id="什么是未跟踪"><a class="header" href="#什么是未跟踪">什么是「未跟踪」？</a></h3>
<p>所谓「未跟踪」，就是字面意义上的未跟踪，Git 对这个文件的状态一无所知，只知道这是一个「未跟踪」的文件。当一个文件第一次被建立，在 Git 中还没有历史记录的时候，它就是「未跟踪」的。</p>
<p>听起来好像没什么，只是翻来覆去说同一件事而已。但实际上，Git 很多出人意料的行为，都和这个「未跟踪」有关。</p>
<h3 id="怪异之一我在-stash-什么"><a class="header" href="#怪异之一我在-stash-什么">怪异之一：我在 stash 什么？</a></h3>
<p><code>git stash</code> 是一个很实用的命令。当你在一个分支有未完成的工作，这时想要切换到另一个分支，但不想草率地把做到一半的工作给提交，就可以用 <code>git stash</code> 临时贮藏起来，等到另一个分支上的工作完成之后，再 <code>git stash pop</code> 释放出未完成的部分。</p>
<p>现在问题来了，当前工作区的状态是这样的：</p>
<pre><code> M a.txt
A  b.txt
M  c.txt
?? d.txt
</code></pre>
<p>请问：<code>git stash</code> 之后，当前工作区的状态是什么样子？</p>
<p>答案是：<code>a.txt</code> <code>b.txt</code> <code>c.txt</code> 都被成功贮藏，并且恢复到了最后一次提交的状态。而 <code>d.txt</code> 没有被贮藏，依然是「未跟踪」。</p>
<p>很出人意料。明明在 <code>d.txt</code> 里也有未完成的工作，为什么就不能贮藏呢？</p>
<p>原因就是 <code>d.txt</code> 是一个「未跟踪」的文件，Git 不知道关于它的细节，所以不会贮藏它。</p>
<p><em>（实际上，我在写作这一节的时候就被这个现象坑到了。如果不是我意识到似乎有什么不对，提前复制了文件的内容，大家可能就见不到这一节了。）</em></p>
<h3 id="怪异之二我在-checkout-什么"><a class="header" href="#怪异之二我在-checkout-什么">怪异之二：我在 checkout 什么？</a></h3>
<p>众所周知，在工作目录里有修改过但未提交的文件时，是不能切换到别的分支的。</p>
<p>但是如果工作目录里除去未修改的文件，只有未跟踪的文件，这种情况下是可以切换到别的分支的。并且切换过去之后，这些未跟踪的文件不会发生什么变化，依然是未跟踪文件。</p>
<p>如果这个时候你不小心用了 <code>git add .</code>，那么恭喜你，你成功把一个不相干的文件放进了暂存区。</p>
<p>你可能会认为是 Git 不知道未跟踪文件的存在，所以无视了它。但是，如果在切换到别的分支时，有另一个分支的文件会把这个未跟踪文件覆盖掉，那么 Git 会坚决阻止这次切换。那么，Git 到底是以怎样的态度对待未跟踪文件的？为什么一会无视，一会又在保护它呢？</p>
<h3 id="git-在任何情况下不会隐式地修改未跟踪的文件"><a class="header" href="#git-在任何情况下不会隐式地修改未跟踪的文件">Git 在任何情况下不会隐式地修改未跟踪的文件</a></h3>
<p>其实，这些怪异之处，都能用一条逻辑来概括：<strong>Git 在任何情况下不会隐式地修改未跟踪的文件。</strong></p>
<p>在 <code>stash</code> 的例子中，如果 Git 把未跟踪文件贮藏了，那么意味着 Git 需要删除一个未跟踪的文件。这是不被允许的，因为 <code>git stash</code> 不具有删除的语义。</p>
<p>在 <code>checkout</code> 的例子中，如果 Git 允许切换分支时彻底无视未跟踪文件，那么其他分支的文件就有可能把未跟踪文件覆盖掉，这也是不被允许的。</p>
<p>至于为什么在工作目录里有未跟踪文件时还允许签出，我没有想到一个很完美的解释。一种可能是这种行为没有违背不修改未跟踪文件的规则，另一种可能是为了允许先新增文件，再新建分支。</p>
<p>当然，<strong>Git 从来不会彻底阻止你干什么事情的</strong>。显式地修改未跟踪地文件是允许的。比如 <code>git clean</code>，它的意思是删掉所有未跟踪的文件。Git 知道当你打下这句命令时，你确实清楚你要对未跟踪的文件进行操作，所以 Git 不会阻止你。</p>
<p>Git 处处都在保证你的文件的安全性，但也不会阻止你意图明确地做一些不安全的事情。这是 Git 的哲学中最耐人寻味之处，只有真正的相互理解，才能托付彼此的真心。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="约定式提交"><a class="header" href="#约定式提交">约定式提交</a></h1>
<blockquote>
<p>部分内容参考自约定式提交的<a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">官方网站</a>，在原文基础上有一定修改。</p>
</blockquote>
<h2 id="什么是约定式提交"><a class="header" href="#什么是约定式提交">什么是约定式提交？</a></h2>
<p>约定式提交规范是一种基于提交信息的轻量级约定，换句话说，它规定了你应该用什么格式写提交信息。</p>
<p>一段符合约定式提交的 git log 看起来是这样的（来自 <a href="https://github.com/unocss/unocss">unocss</a>）：</p>
<pre><code>* 1762ef93 - (tag: v0.33.3) release v0.33.3
* 7b3b8a97 - chore: update deps
* eccaed9d - chore: bump pnpm
* a1fac007 - feat(vite): support build watch mode (#963)
* fa1e8202 - fix(vite): emit better warning in build (#961)
* 89003436 - feat(preset-mini): add break-spaces to white-space (#962)
* b0fd9a83 - feat(vscode): support loading from iles.config file (#956)
* bcaa6eed - docs: update
* 6e6f07e5 - docs: update features
* 31a24fd1 - (tag: v0.33.2) release v0.33.2
* d2d0c497 - chore: lint
* d051b5c0 - feat(compile-class): new transformer (#950)
* 10c0ae28 - docs: fix query loading
* 59403676 - (tag: v0.33.1) release v0.33.1
</code></pre>
<h2 id="为什么要使用约定式提交"><a class="header" href="#为什么要使用约定式提交">为什么要使用约定式提交？</a></h2>
<ul>
<li>自动化生成 CHANGELOG。</li>
<li>基于提交的类型，自动决定语义化的版本变更。</li>
<li>向同事、公众与其他利益关系者传达变化的性质。</li>
<li>触发构建和部署流程。</li>
<li>让人们探索一个更加结构化的提交历史，以便降低对你的项目做出贡献的难度。</li>
</ul>
<h2 id="约定式提交的格式是怎样的"><a class="header" href="#约定式提交的格式是怎样的">约定式提交的格式是怎样的？</a></h2>
<h3 id="一般格式"><a class="header" href="#一般格式">一般格式</a></h3>
<p>对于单行提交，约定式提交的格式是这样的：</p>
<pre><code>type(scope): description
</code></pre>
<p>对于多行提交，约定式提交的格式是这样的：</p>
<pre><code>type(scope): description

body

footers
</code></pre>
<p>其中，<code>type</code> 是提交做出更改的类型，它可以为：</p>
<ul>
<li><strong>fix</strong>：表示在代码库中修复了一个 bug（这和语义化版本中的 <a href="https://semver.org/lang/zh-CN/#%E6%91%98%E8%A6%81">PATCH</a> 相对应）。</li>
<li><strong>feat</strong>：表示在代码库中新增了一个功能（这和语义化版本中的 <a href="https://semver.org/lang/zh-CN/#%E6%91%98%E8%A6%81">MINOR</a> 相对应）。</li>
<li>除 <code>fix:</code> 和 <code>feat:</code> 之外，也可以使用其它提交类型，例如 <a href="https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional">@commitlint/config-conventional</a>（基于 <a href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">Angular 约定</a>）中推荐的 <code>build:</code>、<code>chore:</code>、<code>ci:</code>、<code>docs:</code>、<code>style:</code>、<code>refactor:</code>、<code>perf:</code>、<code>test:</code>，等等。</li>
</ul>
<p><code>scope</code> 是此次更改涉及到的项目子模块范围。如果不能明确，这一部分可以省略。</p>
<p><code>description</code> 是描述此次更改的简短描述。</p>
<h3 id="破坏性更改"><a class="header" href="#破坏性更改">破坏性更改</a></h3>
<p>当提交的内容包含破坏性更改时，必须在描述中指出，例如：</p>
<pre><code>feat!: send an email to the customer when a product is shipped
</code></pre>
<pre><code>feat: allow provided config object to extend other configs

BREAKING CHANGE: `extends` key in config file is now used for extending other config files
</code></pre>
<p>在冒号前面加上 <code>!</code> ，或者在脚注中表明 <code>BREAKING CHANGE</code>，就表示此次更改是破坏性更改。</p>
<h2 id="约定式提交的正式规范"><a class="header" href="#约定式提交的正式规范">约定式提交的正式规范</a></h2>
<p>详见<a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/#%E7%BA%A6%E5%AE%9A%E5%BC%8F%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83">官方网站</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitmoji-速查表"><a class="header" href="#gitmoji-速查表">gitmoji 速查表</a></h1>
<blockquote>
<p>下面是一些常用的 gitmoji。完整的列表可以参见 <a href="https://gitmoji.js.org/">Gitmoji 的网站</a>。</p>
</blockquote>
<table><thead><tr><th>提交类型</th><th>Emoji</th><th>代码</th></tr></thead><tbody>
<tr><td>创世提交。</td><td>🎉</td><td>:tada:</td></tr>
<tr><td>引入不兼容改动。</td><td>💥</td><td>:boom:</td></tr>
<tr><td>性能改善。</td><td>⚡️</td><td>:zap:</td></tr>
<tr><td>删除代码或者文件。</td><td>🔥</td><td>:fire:</td></tr>
<tr><td>修了一个 BUG。</td><td>🐛</td><td>:bug:</td></tr>
<tr><td>重大热修复。</td><td>🚑</td><td>:ambulance:</td></tr>
<tr><td>修复安全问题。</td><td>🔒</td><td>:lock:</td></tr>
<tr><td>引入新的特性。</td><td>✨</td><td>:sparkles:</td></tr>
<tr><td>结构改进 / 格式化代码。</td><td>🎨</td><td>:art:</td></tr>
<tr><td>更新界面与样式文件。</td><td>💄</td><td>:lipstick:</td></tr>
<tr><td>更新测试。</td><td>✅</td><td>:white_check_mark:</td></tr>
<tr><td>代码重构。</td><td>♻️</td><td>:recycle:</td></tr>
<tr><td>写文档。</td><td>📝</td><td>:pencil:</td></tr>
<tr><td>发布 / 版本标签</td><td>🔖</td><td>:bookmark:</td></tr>
<tr><td>进行中。</td><td>🚧</td><td>:construction:</td></tr>
<tr><td>改变配置文件。</td><td>🔧</td><td>:wrench:</td></tr>
<tr><td>国际化与本地化。</td><td>🌐</td><td>:globe_with_meridians:</td></tr>
<tr><td>修正拼写错误。</td><td>✏️</td><td>:pencil2:</td></tr>
<tr><td>回滚改动。</td><td>⏪</td><td>:rewind:</td></tr>
<tr><td>合并分支。</td><td>🔀</td><td>:twisted_rightwards_arrows:</td></tr>
<tr><td>更新编译后的文件或者包。</td><td>📦</td><td>:package:</td></tr>
<tr><td>添加或者更新许可。</td><td>📄</td><td>:page_facing_up:</td></tr>
<tr><td>添加一个彩蛋。</td><td>🥚</td><td>:egg:</td></tr>
<tr><td>添加或者更新 .gitignore 文件。</td><td>🙈</td><td>:see_no_evil:</td></tr>
</tbody></table>

                        <br />
                        <div class="giscus"></div>
                        <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                    </main>
                </div>
            </div>
        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/sidetoc.js"></script>
        <script type="text/javascript" src="assets/giscus.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
